1.MAXIMUM XOR OF TWO NON-OVERLAPPING STRUCTURES
algorithm
Construct the Graph:
Create an adjacency list representation of the tree from the given edges.
Calculate the Maximum XOR:
Iterate over each node in the graph.
For each node, iterate over its neighbors.
Calculate the XOR of the node's value and its neighbor's value.
Update the maximum XOR if the current XOR is greater.
Return the Maximum XOR:
Return the maximum XOR calculated in the previous step.
code:
class Solution:
    def maximumXOR(self, n, edges, values):
        graph = [[] for _ in range(n)]
        for edge in edges:
            graph[edge[0]].append(edge[1])
            graph[edge[1]].append(edge[0])
        max_xor = 0
        for node in range(n):
            for neighbor in graph[node]:
                max_xor = max(max_xor, values[node] ^ values[neighbor])
        return max_xor
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2.FORM A CHEMICAL BOND
algorithm
Create a Dictionary:
Create a dictionary to store the elements and their types.
Find Metal and Nonmetal Elements:
Iterate over the elements and identify the metal and nonmetal elements.
Form Bonds:
For each metal element, iterate over the nonmetal elements and form a bond if they match the criteria.
Return the Result:
Return the list of formed bonds.
code:
class Solution:
    def formaChemicalBond(self, elements):
        elements_dict = {}
        for element in elements:
            elements_dict[element[0]] = element[1]
        result = []
        for metal in elements_dict:
            if elements_dict[metal] == 'Metal':
                for nonmetal in elements_dict:
                    if elements_dict[nonmetal] == 'Nonmetal':
                        result.append((metal, nonmetal))
        return result
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.MINIMUM CUTS TO DIVIDE A CIRCLE
algorithm
Calculate the Minimum Cuts:
The minimum number of cuts needed to divide a circle into n equal slices is n - 1.
code:
class Solution:
    def minCuts(self, n):
        return n - 1
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4.DIFFERENCE BETWEEN ONCE AND ZEROS IN ROWS AND COLUMNS
algorithm
Initialize Variables:
Initialize the minimum penalty to infinity and the minimum hour to 0.
Iterate over Possible Closing Hours:
Iterate over the possible closing hours from 0 to the length of the customers string.
Calculate Penalty for Current Closing Hour:
For each closing hour, calculate the penalty by:
Counting the number of hours when the shop is open and no customers come.
Counting the number of hours when the shop is closed and customers come.
Adding these two counts to get the total penalty.
Update Minimum Penalty and Hour:
If the current penalty is less than the minimum penalty, update the minimum penalty and the minimum hour.
Return the Minimum Hour:
Return the minimum hour as the result.
code:
class Solution:
    def minPenalty(self, customers):
        n = len(customers)
        min_penalty = float('inf')
        min_hour = 0
        for j in range(n + 1):
            penalty = 0
            for i in range(j):
                if customers[i] == 'N':
                    penalty += 1
            for i in range(j, n):
                if customers[i] == 'Y':
                    penalty += 1
            if penalty < min_penalty:
                min_penalty = penalty
                min_hour = j
        return min_hour
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5.MINIMUM PENALTY FOR A SHOP
algorithm:
Initialize Variables:
Initialize the minimum penalty to infinity and the minimum hour to 0.
Iterate over Possible Closing Hours:
Iterate over the possible closing hours from 0 to the length of the customers string.
Calculate Penalty for Current Closing Hour:
For each closing hour, calculate the penalty by:
Counting the number of hours when the shop is open and no customers come.
Counting the number of hours when the shop is closed and customers come.
Adding these two counts to get the total penalty.
Update Minimum Penalty and Hour:
If the current penalty is less than the minimum penalty, update the minimum penalty and the minimum hour.
Return the Minimum Hour:
Return the minimum hour as the result.
CODE:
class Solution:
    def minPenalty(self, customers):
        n = len(customers)
        min_penalty = float('inf')
        min_hour = 0
        for j in range(n + 1):
            penalty = 0
            for i in range(j):
                if customers[i] == 'N':
                    penalty += 1
            for i in range(j, n):
                if customers[i] == 'Y':
                    penalty += 1
            if penalty < min_penalty:
                min_penalty = penalty
                min_hour = j
        return min_hour
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6.COUNT PALINDROMIC SUNSEQUENCE
ALGORITHM:
Initialize a 2D array dp of size (n+1) x (n+1), where n is the length of the input string s. dp[i][j] will store the number of palindromic subsequences of length j-i+1 in the substring s[i:j+1].
Initialize the diagonal elements dp[i][i] to 1, as a single character is a palindromic subsequence of length 1.
Iterate through the lengths of the subsequences, from 2 to n.
For each length, iterate through the starting indices i from 0 to n-length+1.
Calculate the ending index j = i + length - 1.
If the characters at indices i and j are the same, then the number of palindromic subsequences is the number of palindromic
subsequences in the substring s[i+1:j] (i.e., dp[i+1][j-1]) plus 2 (for the palindromic subsequences that start and end with the characters at indices i and j).
If the characters at indices i and j are different, then the number of palindromic subsequences is the sum of 
the number of palindromic subsequences in the substring s[i+1:j+1] (i.e., dp[i+1][j]) and the number of palindromic 
subsequences in the substring s[i:j] (i.e., dp[i][j-1]), minus the number of palindromic subsequences in the substring s[i+1:j] (i.e., dp[i+1][j-1]), to avoid double-counting.
After filling the dp array, return the value stored in dp[n-1] as the final answer, modulo 10^9 + 7.
CODE:
def countPalindromicSubsequences(s):
    MOD = 10**9 + 7
    n = len(s)
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        dp[i][i] = 1
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j]:
                dp[i][j] = dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]
            dp[i][j] %= MOD
    return dp[0][n - 1]
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7.FIND THE PIVOT INTEGER
ALGORITHM:
Calculate the total sum of all numbers from 1 to n using the formula sum(range(1, n + 1)).
Initialize a variable left_sum to 0, which will store the sum of numbers from 1 to x.
Iterate through the numbers from 1 to n.
For each number i, add i to left_sum.
Check if left_sum equals the total sum minus left_sum. If it does, return i as the pivot integer.
If no such integer is found, return -1.
CODE:
def pivotInteger(n):
    total = sum(range(1, n + 1))
    left_sum = 0
    for i in range(1, n + 1):
        left_sum += i
        if left_sum == total - left_sum:
            return i
    return -1
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
